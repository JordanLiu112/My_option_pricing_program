///Jordan Liu - Groups A and B - Exact Pricing Methods
//Batch 1: S = 60, K = 65, T = 0.25, r = 0.08, sig = 0.30, (C = 2.13337, P = 5.84628). 
//Batch 2: S = 100, K = 100, T = 1.0, r = 0.0, sig = 0.2, (C = 7.96557, P = 7.96557).
//Batch 3 : S = 5, K = 10, T = 1.0, r = 0.12, sig = 0.50, (C = 0.204058, P = 4.07326).
//Batch 4 : S = 100.0, K = 100.0, T = 30.0, r = 0.08, sig = 0.30, (C = 92.17570, P = 1.24750).
//Batch 5: S = 105, K = 100, T = 0.5, r = 0.1, sig = 0.36, b = 0 (delta call = 0.5946, delta put = -0.3566)
//Batch 6: S = 110, K = 100, r = 0.1, sig = 0.1, b = 0.02 (C = 18.5035, P = 3.03106)
//European options constructors: EuroOption(S1, K1, T1, r1, sig1, b1), EuroOption(S1, K1, T1, r1, sig1)
//Greek constructors: Greek(S1, K1, T1, r1, sig1, b1), Greek(S1, K1, T1, r1, sig1)
//US perpetual constructor: US_Perpetual(S1, K1, r1, sig1, b1)
//Made EuroOption, Greek, US_Perpetual derived classes of BlackScholes, created ParamMatrix class, redesigned the matrix pricer 
//Matrix pricer now takes a generic parameter matrix or a vector of options and returns a vector of prices

#include "ParamMatrix.h"

using namespace std;
 

int main() {
	EuroOption batch1, batch2(100, 100, 1.0, 0.0, 0.2), batch3(5, 10, 1.0, 0.12, 0.50), batch4(100.0, 100.0, 30.0, 0.08, 0.30);
	EuroOption batch9(102, 122, 1.65, 0.045, 0.43, 0);
	Greek batch10(102, 122, 1.65, 0.045, 0.43, 0);
	printBatch(9, batch9.callPrice(), batch9.putPrice());
	printGreeks(batch10, 9);

	cout << "\n\n***Group A - Implement the formulae for call and put option pricing.\n\n";
	cout << "The output should read:" << endl;
	cout << "Batch 1: C = 2.13337, P = 5.84628 \nBatch 2 : C = 7.96557, P = 7.96557 \nBatch 3 : C = 0.204058, P = 4.07326 \nBatch 4 : C = 92.17570, P = 1.24750" << endl << endl;
	cout << "Output: " << endl;
	printBatch(1, batch1.callPrice(), batch1.putPrice()); //test the call and put option pricing formulae implementation
	printBatch(2, batch2.callPrice(), batch2.putPrice());
	printBatch(3, batch3.callPrice(), batch3.putPrice());
	printBatch(4, batch4.callPrice(), batch4.putPrice());

	cout << endl << "***Group A - Apply the put-call parity relationship to compute call and put option prices" << endl << endl;
	printBatch(1, batch1.callPrice(5.84628), batch1.putPrice(2.13337));
	printBatch(2, batch2.callPrice(7.96557), batch2.putPrice(7.96557));
	printBatch(3, batch3.callPrice(4.07326), batch3.putPrice(0.204058));
	printBatch(4, batch4.callPrice(1.24750), batch4.putPrice(92.17570));
	cout << endl << "(Notice the very slight rounding error for batch 3 when we compute its call price from its put price)" << endl << endl;
	printParity(2.13337, 5.84628, batch1.verifyParity(2.13337, 5.84628));
	printParity(7.96557, 7.96557, batch2.verifyParity(7.96557, 7.96557));
	printParity(0.204058, 4.07326, batch3.verifyParity(0.204058, 4.07326));
	printParity(92.17570, 1.24750, batch4.verifyParity(92.17570, 1.24750));
	
	cout << endl << "***Group A - Compute option prices for a monotonically increasing range of underlying values of S" << endl << endl;
	vector<double> S_values1 = makeMesh(45, 55, 1); ///generate mesh array of S values
	cout << "For Batch 1: " << endl;
	printMesh(S_values1, batch1.callPrice(S_values1), batch1.putPrice(S_values1)); //print S values and their corresponding call and put prices for batch 1 

	//matrix code exercise here
	cout << endl << "***Group A - Extend part c) so we can input a matrix of option parameters (e.g. S and T) and receive a matrix of option prices" << endl << endl;
	ParamMatrix param1, param2;
	//param1.loadConsole(); //uncomment to load by console 
	//param1.print();
	//printMeshPrice(param1.callMatrix(batch1, "price")); //adjust as needed
	param2.loadMesh({ 60, 65, 0.25, 0.08, 0.30, 0.08 }, "SKTrsb"); //load by mesh
	param2.loadBatch(batch2);
	param2.loadBatch(batch3); //load by batch
	param2.loadBatch(batch4);
	cout << "Parameter matrix: \n\n";
	param2.print(); //print parameter matrix
	cout << "\nCall prices: \n\n";
	printMeshPrice(param2.callMatrix(batch1, "price")); //prints the price vector generated by the matrix pricer
	cout << "\nPut prices: \n\n";
	printMeshPrice(param2.putMatrix(batch2, "price"));


	cout << endl << "***Group A - Implement the formulae for option sensitivities with specified data set ('Batch 5')" << endl;
	cout << "Batch 5: S = 105, K = 100, T = 0.5, r = 0.1, sig = 0.36, b = 0\n";
	cout << "The output should show delta call = 0.5946, delta put = -0.3566" << endl << endl;
	Greek batch5 = Greek(); //create Greek class object (default constructor sets batch 5 values)
	printGreeks(batch5, 5);

	cout << endl << "***Group A - compute call delta price for a monotonically increasing range of underlying values of S" << endl << endl;
	vector<double> S_values5 = makeMesh(100, 110, 1); ///generate mesh array of S values
	cout << "For Batch 5: " << endl;
	printMesh(S_values5, batch5.callDelta(S_values5), batch5.putDelta(S_values5)); //print S values and their corresponding call and put deltas for batch 5

	//adjust matrix code here
	cout << endl << "***Group A - adjust matrix code to accept a matrix of option parameters and return a mesh of Delta or Gamma" << endl << endl;
	param2.loadMesh({ 105, 0.5 }, "ST"); //load the S and T values of batch 5
	cout << "Parameter matrix: " << endl;
	param2.print();
	cout << "\nThe corresponding call deltas for the parameter matrix, applied to batch 5, is: \n\n";
	printMeshPrice(param2.callMatrix(batch5, "delta"));
	cout << "\nThe corresponding call gammas for the parameter matrix, applied to batch 5, is: \n\n";
	printMeshPrice(param2.callMatrix(batch5, "gamma"));
	cout << "\nThe corresponding put deltas for the parameter matrix, applied to batch 5, is: \n\n";
	printMeshPrice(param2.putMatrix(batch5, "delta"));
	cout << "\nThe corresponding put gammas for the parameter matrix, applied to batch 5, is: \n\n";
	printMeshPrice(param2.putMatrix(batch5, "gamma"));

	cout << endl << "***Group A - Use divided differences to approximate option sensitivities" << endl << endl;
	printCompare(S_values5, batch5, 0.01); //h = 0.01
	cout << endl << "Now let's set h = 5 and see how this worsens the approximations\n\n";
	printCompare(S_values5, batch5, 5); //h = 5

	cout << endl << "***Group B - Program the formulae for American perpetual options" << endl << endl;
	//Test data with S = 110, K = 100, T = 0 (for perpetuals), r = 0.1, sig = 0.1, b = 0.02, (check C = 18.5035, P = 3.03106)
	US_Perpetual batch6 = US_Perpetual(); //default constructor sets batch 6 values
	cout << "Output for batch 6 (S = 110, K = 100, r = 0.1, sig = 0.1, b = 0.02) should read C = 18.5035, P = 3.03106\n\n";
	printBatch(6, batch6.callPrice(), batch6.putPrice());

	cout << "\n***Group B - compute US perpetual option prices for a monotonically increasing range of values of S\n\n";
	vector<double> S_values6 = makeMesh(105, 115, 1); //get vector of appropriate S values
	printMesh(S_values6, batch6.callPrice(S_values6), batch6.putPrice(S_values6));
	
	//american matrix

	cout << "\n***Group B - input a matrix of option parameters and receive a mesh of Perpetual American option prices \n\nParameter matrix: \n";
	ParamMatrix param3;
	param3.loadMesh({ 110, 100, 0.1, 0.1, 0.02 }, "SKrsb");
	param3.loadBatch(batch6); //test if ParamMatrix can load a US_Perpetual class object (it should)
	param3.loadMesh({ 100, 90, 0.12 }, "SKr"); //can adjust any mix of parameters
	param3.loadMesh({ 0.09, 95, 0.03 }, "sKb");
	param3.loadMesh({ 0.08 }, "r"); 
	param3.print();
	cout << "\nThe corresponding US perpetual call prices for the parameter matrix is: \n\n";
	printMeshPrice(param3.callMatrix(batch6, "price"));
	cout << "\nThe corresponding US perpetual put prices for the parameter matrix is: \n\n";
	printMeshPrice(param3.putMatrix(batch6, "price"));
	return 0;
}


